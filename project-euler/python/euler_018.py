"""
Problem 018. 삼각형을 따라 내려가면서 합이 최대가 되는 경로 찾기



## 문제
다음과 같이 삼각형 모양으로 수를 배열했습니다.

   3
  7 4
 2 4 6
8 5 9 3

삼각형의 꼭대기부터 아래쪽으로 인접한 수를 찾아 내려가면서 합을 구하면, 위의 그림처럼 3 + 7 + 4 + 9 = 23 이 가장 큰 합을 갖는 경로가 됩니다.

다음 삼각형에서 합이 최대가 되는 경로를 찾아서 그 합을 구하세요.

                 75
                95 64
               17 47 82
              18 35 87 10
            20 04 82 47 65
           19 01 23 75 03 34
          88 02 77 73 07 63 67
         99 65 04 28 06 16 70 92
       41 41 26 56 83 40 80 70 33
      41 48 72 33 47 32 37 16 94 29
     53 71 44 65 25 43 91 52 97 51 14
    70 11 33 28 77 73 17 78 39 68 17 57
  91 71 52 38 17 14 91 43 58 50 27 29 48
 63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23

참고: 여기서는 경로가 16384개밖에 안되기 때문에, 모든 경로의 합을 일일이 계산해서 답을 구하는 것이 가능합니다.
하지만 67번 문제에는 100층짜리 삼각형 배열이 나옵니다. 그런 경우에는 좀 더 현명한 풀이 방법을 찾아야겠지요.



## 풀이
### 동적 계획법(dynamic programming)
주어진 문제를 여러 개의 하위 문제로 나누어 푼 다음, 그것을 결합하여 최종 결과값을 얻는 것이다. 
각 하위 문제를 해결한 결과값을 저장한 뒤, 후에 같은 하위 문제가 나왔을 경우 단순히 조회하는 것 만으로 간단하게 해결할 수 있다. 
이러한 방법으로 동적 계획법은 계산 횟수를 줄인다. 
특히 이 방법은 하위 문제의 수가 기하급수적으로 증가할 때 유용하다.

동적 계획 알고리즘은 최단 경로 문제, 행렬의 제곱 문제 등의 최적화에 사용된다. 
이것은 동적 계획법은 문제를 해결하기 위한 모든 방법을 검토하고, 그 중에 최적의 풀이법을 찾아내기 때문이다. 
때로는 단순히 재귀함수의 결과값을 저장하여 재사용하는 것 만으로도 최적해를 구할 수 있는 동적 알고리즘을 찾을 수 있다.



## 출처
https://euler.synap.co.kr/problem=18
"""

import sys
from sys import stdin

mock_data = iter([
    '15', 
    '75', 
    '95 64', 
    '17 47 82', 
    '18 35 87 10', 
    '20 04 82 47 65', 
    '19 01 23 75 03 34', 
    '88 02 77 73 07 63 67', 
    '99 65 04 28 06 16 70 92', 
    '41 41 26 56 83 40 80 70 33', 
    '41 48 72 33 47 32 37 16 94 29', 
    '53 71 44 65 25 43 91 52 97 51 14', 
    '70 11 33 28 77 73 17 78 39 68 17 57', 
    '91 71 52 38 17 14 91 43 58 50 27 29 48', 
    '63 66 04 68 89 53 67 30 73 16 69 87 40 31', 
    '04 62 98 27 23 09 70 98 73 93 38 53 60 04 23', 
    ])


readline = lambda: next(mock_data)
sys.stdin.readline = readline
stdin.readline = readline


# ---------- Divider ----------
# Answer


def find_max_path_sum_dp(tri: list[list[int]]) -> int:
    dp: list[list[int]] = [row[:] for row in tri]
    
    for i in range(len(tri) - 2, -1, -1):
        for j in range(len(tri[i])):
            dp[i][j] += max(dp[i + 1][j], dp[i + 1][j + 1])
    
    return dp[0][0]


from sys import stdin

n: int = int(stdin.readline())
tri: list[list[int]] = [[0] for _ in range(n)]

for i in range(n):
    tri[i] = [int(s) for s in stdin.readline().split(' ')]
    
max_path: int = find_max_path_sum_dp(tri)

print(max_path)